/**\n * Tauri Desktop API Service\n * \n * Handles desktop-specific operations including:\n * - Database sync and backup\n * - File system operations\n * - Local storage management\n * - System notifications\n */\n\nclass TauriDesktopAPI {\n  constructor() {\n    this.isDesktop = window.__TAURI__ !== undefined;\n    this.tauri = null;\n    this.fs = null;\n    this.dialog = null;\n    this.notification = null;\n    \n    if (this.isDesktop) {\n      this.initTauriAPIs();\n    }\n  }\n\n  async initTauriAPIs() {\n    try {\n      // Dynamically import Tauri APIs\n      const [tauriCore, tauriFs, tauriDialog, tauriNotification] = await Promise.all([\n        import('@tauri-apps/api/core'),\n        import('@tauri-apps/api/fs'),\n        import('@tauri-apps/api/dialog'),\n        import('@tauri-apps/api/notification')\n      ]);\n      \n      this.tauri = tauriCore;\n      this.fs = tauriFs;\n      this.dialog = tauriDialog;\n      this.notification = tauriNotification;\n      \n      console.log('ðŸ–¥ï¸ Tauri APIs initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Tauri APIs:', error);\n    }\n  }\n\n  /**\n   * Database Sync Operations\n   */\n  async syncDatabase(remoteConfig) {\n    if (!this.isDesktop) {\n      throw new Error('Database sync is only available in desktop mode');\n    }\n\n    try {\n      const { host, port, database, username, password, useSSL } = remoteConfig;\n      const protocol = useSSL ? 'https' : 'http';\n      const baseUrl = `${protocol}://${host}${port ? `:${port}` : ''}`;\n\n      // Fetch remote data\n      const response = await fetch(`${baseUrl}/api/sync/`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${localStorage.getItem('access_token')}`\n        },\n        body: JSON.stringify({\n          last_sync: localStorage.getItem('last_sync_timestamp'),\n          client_id: this.getClientId()\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Sync failed: ${response.statusText}`);\n      }\n\n      const syncData = await response.json();\n      \n      // Save sync data locally\n      await this.saveLocalData(syncData);\n      \n      // Update last sync timestamp\n      localStorage.setItem('last_sync_timestamp', new Date().toISOString());\n      \n      return {\n        success: true,\n        recordsUpdated: syncData.updated_records || 0,\n        recordsAdded: syncData.new_records || 0,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Database sync failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Backup Operations\n   */\n  async createBackup() {\n    if (!this.isDesktop) {\n      throw new Error('Backup is only available in desktop mode');\n    }\n\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const defaultPath = `clinic_backup_${timestamp}.json`;\n      \n      const filePath = await this.dialog.save({\n        title: 'Save Backup File',\n        defaultPath,\n        filters: [{\n          name: 'JSON Files',\n          extensions: ['json']\n        }]\n      });\n\n      if (!filePath) {\n        return { success: false, message: 'Backup cancelled by user' };\n      }\n\n      // Collect all local data\n      const backupData = await this.collectBackupData();\n      \n      // Write to file\n      await this.fs.writeTextFile(filePath, JSON.stringify(backupData, null, 2));\n      \n      return {\n        success: true,\n        filePath,\n        size: JSON.stringify(backupData).length,\n        timestamp: backupData.metadata.timestamp\n      };\n    } catch (error) {\n      console.error('Backup creation failed:', error);\n      throw error;\n    }\n  }\n\n  async restoreBackup() {\n    if (!this.isDesktop) {\n      throw new Error('Restore is only available in desktop mode');\n    }\n\n    try {\n      const filePath = await this.dialog.open({\n        title: 'Select Backup File',\n        multiple: false,\n        filters: [{\n          name: 'JSON Files',\n          extensions: ['json']\n        }]\n      });\n\n      if (!filePath) {\n        return { success: false, message: 'Restore cancelled by user' };\n      }\n\n      // Read backup file\n      const content = await this.fs.readTextFile(filePath);\n      const backupData = JSON.parse(content);\n      \n      // Validate backup structure\n      if (!this.validateBackupData(backupData)) {\n        throw new Error('Invalid backup file format');\n      }\n      \n      // Restore data\n      await this.restoreLocalData(backupData);\n      \n      return {\n        success: true,\n        recordsRestored: backupData.data?.records?.length || 0,\n        backupDate: backupData.metadata?.timestamp\n      };\n    } catch (error) {\n      console.error('Backup restore failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Local Data Operations\n   */\n  async saveLocalData(data) {\n    try {\n      // Save to localStorage\n      Object.keys(data).forEach(key => {\n        localStorage.setItem(`local_${key}`, JSON.stringify(data[key]));\n      });\n      \n      // Save to file system if available\n      if (this.fs) {\n        await this.fs.writeTextFile('local_data.json', JSON.stringify(data, null, 2));\n      }\n    } catch (error) {\n      console.error('Failed to save local data:', error);\n      throw error;\n    }\n  }\n\n  async collectBackupData() {\n    const backupData = {\n      metadata: {\n        version: '1.0.0',\n        timestamp: new Date().toISOString(),\n        clientId: this.getClientId(),\n        appVersion: process.env.REACT_APP_VERSION || '1.0.0'\n      },\n      data: {\n        patients: this.getLocalStorageData('patients'),\n        appointments: this.getLocalStorageData('appointments'),\n        examinations: this.getLocalStorageData('examinations'),\n        diagnoses: this.getLocalStorageData('diagnoses'),\n        settings: this.getLocalStorageData('desktop_settings'),\n        userPreferences: this.getLocalStorageData('user_preferences')\n      }\n    };\n    \n    return backupData;\n  }\n\n  async restoreLocalData(backupData) {\n    try {\n      const { data } = backupData;\n      \n      // Clear existing data with confirmation\n      const confirmed = await this.confirmRestore();\n      if (!confirmed) {\n        throw new Error('Restore cancelled by user');\n      }\n      \n      // Restore each data type\n      Object.keys(data).forEach(key => {\n        if (data[key]) {\n          localStorage.setItem(key === 'settings' ? 'desktop_settings' : key, JSON.stringify(data[key]));\n        }\n      });\n      \n      // Notify user\n      await this.showNotification('Data Restored', 'Backup has been successfully restored');\n    } catch (error) {\n      console.error('Failed to restore local data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Utility Functions\n   */\n  getClientId() {\n    let clientId = localStorage.getItem('desktop_client_id');\n    if (!clientId) {\n      clientId = 'desktop_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();\n      localStorage.setItem('desktop_client_id', clientId);\n    }\n    return clientId;\n  }\n\n  getLocalStorageData(key) {\n    try {\n      const data = localStorage.getItem(key);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.error(`Failed to parse localStorage data for key: ${key}`, error);\n      return null;\n    }\n  }\n\n  validateBackupData(backupData) {\n    return (\n      backupData &&\n      backupData.metadata &&\n      backupData.metadata.timestamp &&\n      backupData.data &&\n      typeof backupData.data === 'object'\n    );\n  }\n\n  async confirmRestore() {\n    if (!this.dialog) return true;\n    \n    try {\n      const result = await this.dialog.confirm(\n        'This will replace all local data with the backup. Continue?',\n        { title: 'Confirm Restore' }\n      );\n      return result;\n    } catch (error) {\n      console.error('Failed to show confirmation dialog:', error);\n      return false;\n    }\n  }\n\n  async showNotification(title, body) {\n    if (!this.notification) return;\n    \n    try {\n      let permissionGranted = await this.notification.isPermissionGranted();\n      if (!permissionGranted) {\n        const permission = await this.notification.requestPermission();\n        permissionGranted = permission === 'granted';\n      }\n      \n      if (permissionGranted) {\n        await this.notification.sendNotification({ title, body });\n      }\n    } catch (error) {\n      console.error('Failed to send notification:', error);\n    }\n  }\n\n  /**\n   * File Operations\n   */\n  async exportData(data, filename) {\n    if (!this.isDesktop) {\n      // Fallback for web - download as blob\n      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      a.click();\n      URL.revokeObjectURL(url);\n      return;\n    }\n\n    try {\n      const filePath = await this.dialog.save({\n        title: 'Export Data',\n        defaultPath: filename,\n        filters: [{\n          name: 'JSON Files',\n          extensions: ['json']\n        }]\n      });\n\n      if (filePath) {\n        await this.fs.writeTextFile(filePath, JSON.stringify(data, null, 2));\n        return { success: true, filePath };\n      }\n    } catch (error) {\n      console.error('Export failed:', error);\n      throw error;\n    }\n  }\n\n  async importData(allowedExtensions = ['json']) {\n    if (!this.isDesktop) {\n      throw new Error('Import is only available in desktop mode');\n    }\n\n    try {\n      const filePath = await this.dialog.open({\n        title: 'Import Data',\n        multiple: false,\n        filters: [{\n          name: 'Data Files',\n          extensions: allowedExtensions\n        }]\n      });\n\n      if (filePath) {\n        const content = await this.fs.readTextFile(filePath);\n        return { success: true, data: JSON.parse(content) };\n      }\n      \n      return { success: false, message: 'Import cancelled' };\n    } catch (error) {\n      console.error('Import failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * System Integration\n   */\n  async checkForUpdates() {\n    // This would integrate with Tauri's updater plugin\n    try {\n      // Placeholder for update checking logic\n      console.log('Checking for updates...');\n      return { hasUpdate: false, currentVersion: '1.0.0' };\n    } catch (error) {\n      console.error('Update check failed:', error);\n      return { hasUpdate: false, error: error.message };\n    }\n  }\n\n  isDesktopMode() {\n    return this.isDesktop;\n  }\n\n  async getSystemInfo() {\n    if (!this.isDesktop) {\n      return { platform: 'web', version: 'N/A' };\n    }\n\n    try {\n      // This would use Tauri's OS API\n      return {\n        platform: 'desktop',\n        os: 'Unknown', // Would be detected via Tauri\n        version: '1.0.0'\n      };\n    } catch (error) {\n      console.error('Failed to get system info:', error);\n      return { platform: 'desktop', error: error.message };\n    }\n  }\n}\n\n// Create singleton instance\nconst tauriAPI = new TauriDesktopAPI();\n\nexport default tauriAPI;